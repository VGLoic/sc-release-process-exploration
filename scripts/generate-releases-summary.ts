import fs from "fs/promises";
import { ZBuildInfo, toAsyncResult } from "./utils";
/**
 * Based from the `releases` folder content, generate a `releases-summary.ts` file in `scripts/v2` folder.
 * This file contains two constants:
 * - `Contracts` of the form:
 * ```ts
 * export const CONTRACTS = {
 *    "src/Counter.sol/Counter": ["latest", "v1.3.1"],
 *    "src/IncrementOracle.sol/IncrementOracle": ["latest", "v1.3.1"],
 * } as const;
 * ```
 * - `Releases` of the form:
 * ```ts
 * export const RELEASES = {
 *  latest: [
 *    "src/Counter.sol/Counter",
 *    "src/IncrementOracle.sol/IncrementOracle",
 *  ],
 *  "v1.3.1": [
 *    "src/Counter.sol/Counter",
 *    "src/IncrementOracle.sol/IncrementOracle",
 *  ],
 * } as const;
 * ```
 */
async function generateReleasesSummary() {
  // Check if the `releases` folder exists
  const doesReleasesFolderExist = await fs.stat("releases").catch(() => false);
  if (!doesReleasesFolderExist) {
    process.exitCode = 1;
    console.error("The `releases` folder does not exist");
    return;
  }

  // Get the list of releases as directories in the `releases` folder
  const releasesEntriesResult = await toAsyncResult(
    fs.readdir("releases", { withFileTypes: true }),
  );
  if (!releasesEntriesResult.ok) {
    process.exitCode = 1;
    console.error("Error reading the `releases` folder");
    return;
  }
  const releasesDirectories = releasesEntriesResult.value
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name)
    .filter((name) => name !== "generated");

  const releasesPerContracts: Record<string, string[]> = {};
  const contractsPerReleases: Record<string, string[]> = {};

  // For each release, get the `build-info.json` file and get the list of contracts
  for (const release of releasesDirectories) {
    contractsPerReleases[release] = [];

    const buildInfoExists = await fs
      .stat(`releases/${release}/build-info.json`)
      .catch(() => false);
    if (!buildInfoExists) {
      console.warn(`No build-info.json found for release ${release}. Skipping`);
      continue;
    }
    const buildInfoContentResult = await toAsyncResult(
      fs
        .readFile(`releases/${release}/build-info.json`, "utf-8")
        .then(JSON.parse),
    );
    if (!buildInfoContentResult.ok) {
      console.warn(
        `Error reading build-info.json for release ${release}. Skipping`,
      );
      continue;
    }
    const buildInfoResult = ZBuildInfo.safeParse(buildInfoContentResult.value);
    if (!buildInfoResult.success) {
      console.warn(
        `Error parsing build-info.json for release ${release}. Skipping`,
      );
      continue;
    }
    for (const contractPath in buildInfoResult.data.output.contracts) {
      const contracts = buildInfoResult.data.output.contracts[contractPath];
      for (const contractName in contracts) {
        const contractKey = `${contractPath}/${contractName}`;
        contractsPerReleases[release].push(contractKey);
        if (!releasesPerContracts[contractKey]) {
          releasesPerContracts[contractKey] = [];
        }
        releasesPerContracts[contractKey].push(release);
      }
    }
  }

  // Generate the `releases-summary.ts` content
  let releasesSummary = `// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.\n\n`;
  releasesSummary += `export const CONTRACTS = {\n`;
  for (const contractKey in releasesPerContracts) {
    releasesSummary += `  "${contractKey}": ${JSON.stringify(
      releasesPerContracts[contractKey],
    )},\n`;
  }
  releasesSummary += `} as const;\n\n`;

  releasesSummary += `export const RELEASES = {\n`;
  for (const release in contractsPerReleases) {
    releasesSummary += `  "${release}": ${JSON.stringify(
      contractsPerReleases[release],
    )},\n`;
  }
  releasesSummary += `} as const;\n`;

  // Write the `releases-summary.ts` file
  const writeResult = await toAsyncResult(
    fs.writeFile("scripts/releases-summary.ts", releasesSummary),
  );
  if (!writeResult.ok) {
    process.exitCode = 1;
    console.error(
      `Error writing the releases-summary.ts file: ${writeResult.error}`,
    );
    return;
  }
}

generateReleasesSummary();
